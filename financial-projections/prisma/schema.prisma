// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider   = "prisma-client-js"
  engineType = "library"
}

datasource db {
  provider = "postgresql"
}

model Settings {
  id                 String     @id @default(cuid())
  initialBankBalance Decimal    @db.Decimal(10, 2)
  initialBalanceDate DateTime   @db.Date // The date when initial balance is set (typically today on first launch)
  currency           Currency   @default(GBP)
  dateFormat         DateFormat @default(UK)

  // Default bank account for new events
  defaultBankAccountId String?
  defaultBankAccount   BankAccount? @relation(fields: [defaultBankAccountId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([defaultBankAccountId])
}

enum EventType {
  EXPENSE
  INCOMING
}

enum CertaintyLevel {
  UNLIKELY
  POSSIBLE
  LIKELY
  CERTAIN
}

enum RecurrenceFrequency {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  BIANNUAL
  ANNUAL
}

enum Currency {
  GBP
  USD
}

enum DateFormat {
  UK // DD/MM/YYYY
  US // MM/DD/YYYY
}

enum TransactionType {
  DEB // Debit
  DD // Direct Debit
  CHG // Charge
  CR // Credit
  SO // Standing Order
  BP // Bill Payment
  TFR // Transfer
  FPI // Faster Payment In
  FPO // Faster Payment Out
  ATM // ATM Withdrawal
  DEP // Deposit
  INT // Interest
  FEE // Fee
  OTHER // Other
}

enum BankProvider {
  HALIFAX
  LLOYDS
  BANK_OF_SCOTLAND
  BARCLAYS
  HSBC
  NATIONWIDE
  SANTANDER
  NATWEST
  RBS
  TSB
  OTHER
}

enum UploadOperationStatus {
  PENDING
  CHECKING // Preflight validity check in progress
  VALIDITY_CHECK_PASSED // Preflight check passed, awaiting user confirmation
  VALIDITY_CHECK_FAILED // Preflight check failed
  IN_PROGRESS // Upload and processing in progress
  COMPLETED // Successfully completed
  FAILED // Failed during processing
  PARTIAL // Partially completed (some records failed)
}

enum ActivityType {
  CATEGORIZATION_RULE_CREATED
  CATEGORIZATION_RULE_UPDATED
  CATEGORIZATION_RULE_DELETED
  CATEGORIZATION_RULE_APPLIED
  CATEGORIZATION_RULES_APPLIED_ALL
  SPENDING_TYPE_CREATED
  SPENDING_TYPE_UPDATED
  SPENDING_TYPE_DELETED
  SPENDING_TYPES_REMOVED
  TRANSACTION_CREATED
  TRANSACTION_UPDATED
  TRANSACTION_DELETED
  TRANSACTIONS_BULK_DELETED
  TRANSACTIONS_MASS_UPDATED
  CSV_UPLOAD_STARTED
  CSV_UPLOAD_COMPLETED
  CSV_UPLOAD_FAILED
  BANK_ACCOUNT_CREATED
  BANK_ACCOUNT_UPDATED
  BANK_ACCOUNT_DELETED
}

enum ActivityStatus {
  ONGOING
  SUCCESS
  FAILED
  CANCELLED
}

model RecurringProjectionEventRule {
  id          String         @id @default(cuid())
  name        String
  description String?
  value       Decimal        @db.Decimal(10, 2)
  type        EventType
  certainty   CertaintyLevel
  payTo       String? // for expenses
  paidBy      String? // for incoming

  // Decision path for scenario modeling
  decisionPathId String?
  decisionPath   DecisionPath? @relation(fields: [decisionPathId], references: [id], onDelete: SetNull)

  // Bank account association (required)
  bankAccountId String
  bankAccount   BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Restrict)

  // Recurrence definition
  startDate DateTime            @db.Date
  endDate   DateTime            @db.Date // Required to prevent infinite event generation
  frequency RecurrenceFrequency @default(MONTHLY)

  // Generated events
  projectionEvents ProjectionEvent[]

  // Revision tracking for value changes over time
  isBaseRule Boolean @default(true) // true for original rules, false for revisions
  baseRuleId String? // Links revision to its base rule
  baseRule   RecurringProjectionEventRule? @relation("RuleRevisions", fields: [baseRuleId], references: [id], onDelete: Cascade)
  revisions  RecurringProjectionEventRule[] @relation("RuleRevisions")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([decisionPathId])
  @@index([bankAccountId])
  @@index([startDate])
  @@index([baseRuleId])
}

model ProjectionEvent {
  id          String         @id @default(cuid())
  name        String
  description String?
  value       Decimal        @db.Decimal(10, 2)
  type        EventType
  certainty   CertaintyLevel
  payTo       String? // for expenses
  paidBy      String? // for incoming
  date        DateTime       @db.Date

  // Decision path for scenario modeling
  decisionPathId String?
  decisionPath   DecisionPath? @relation(fields: [decisionPathId], references: [id], onDelete: SetNull)

  // Bank account association (required)
  bankAccountId String
  bankAccount   BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Restrict)

  // Link to recurring rule (if generated from one)
  recurringRuleId String?
  recurringRule   RecurringProjectionEventRule? @relation(fields: [recurringRuleId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([date])
  @@index([decisionPathId])
  @@index([bankAccountId])
  @@index([recurringRuleId])
}

model DailyBalance {
  id              String   @id @default(cuid())
  date            DateTime @db.Date
  expectedBalance Decimal  @db.Decimal(10, 2)
  actualBalance   Decimal? @db.Decimal(10, 2) // User can set this

  // Bank account association (required)
  bankAccountId String
  bankAccount   BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([date, bankAccountId])
  @@index([date])
  @@index([bankAccountId])
}

// Track all unique decision paths in the system
model DecisionPath {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "take-new-job", "buy-house"
  description String?
  createdAt   DateTime @default(now())

  // Relations
  scenarioDecisionPaths ScenarioSetDecisionPath[]
  projectionEvents      ProjectionEvent[]
  recurringRules        RecurringProjectionEventRule[]
}

// Named scenario configurations
model ScenarioSet {
  id          String   @id @default(cuid())
  name        String
  description String?
  isDefault   Boolean  @default(false) // The "all enabled" default scenario
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  decisionPaths ScenarioSetDecisionPath[]

  @@index([isDefault])
}

// Junction table: which decision paths are enabled in each scenario
model ScenarioSetDecisionPath {
  id             String  @id @default(cuid())
  scenarioSetId  String
  decisionPathId String
  enabled        Boolean @default(true)

  scenarioSet  ScenarioSet  @relation(fields: [scenarioSetId], references: [id], onDelete: Cascade)
  decisionPath DecisionPath @relation(fields: [decisionPathId], references: [id], onDelete: Cascade)

  @@unique([scenarioSetId, decisionPathId])
  @@index([scenarioSetId])
  @@index([decisionPathId])
}

// Bank Account
model BankAccount {
  id            String       @id @default(cuid())
  name          String
  description   String?
  sortCode      String // Format: "XX-XX-XX"
  accountNumber String // Format: "XXXXXXXX"
  provider      BankProvider @default(OTHER)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  // Relations
  projectionEvents   ProjectionEvent[]
  recurringRules     RecurringProjectionEventRule[]
  dailyBalances      DailyBalance[]
  transactionRecords TransactionRecord[]
  uploadOperations   UploadOperation[]
  defaultForSettings Settings[]

  @@unique([sortCode, accountNumber])
  @@index([sortCode])
}

// Transaction Record (from CSV import)
model TransactionRecord {
  id                     String          @id @default(cuid())
  transactionDate        DateTime        @db.Date
  transactionType        TransactionType
  transactionDescription String
  debitAmount            Decimal?        @db.Decimal(10, 2)
  creditAmount           Decimal?        @db.Decimal(10, 2)
  balance                Decimal         @db.Decimal(10, 2)

  // Bank account association (required)
  bankAccountId String
  bankAccount   BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)

  // Enhancement fields (user-added metadata)
  notes         String?
  spendingTypes TransactionSpendingType[]

  // Link to upload operations via junction table
  uploadSources TransactionUploadSource[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bankAccountId])
  @@index([transactionDate])
}

// Spending Type (for categorization)
model SpendingType {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  color       String? // Hex color code for UI display
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  transactions         TransactionSpendingType[]
  categorizationRules  CategorizationRuleSpendingType[]
}

// Junction table: many-to-many between TransactionRecord and SpendingType
model TransactionSpendingType {
  id                     String  @id @default(cuid())
  transactionRecordId    String
  spendingTypeId         String
  categorizationRuleId   String? // If applied by a rule, track which rule
  appliedManually        Boolean @default(false) // true if user manually added, false if added by rule or import

  transactionRecord    TransactionRecord                @relation(fields: [transactionRecordId], references: [id], onDelete: Cascade)
  spendingType         SpendingType                     @relation(fields: [spendingTypeId], references: [id], onDelete: Cascade)
  categorizationRule   TransactionCategorizationRule?   @relation(fields: [categorizationRuleId], references: [id], onDelete: Cascade)

  @@unique([transactionRecordId, spendingTypeId])
  @@index([transactionRecordId])
  @@index([spendingTypeId])
  @@index([categorizationRuleId])
}

// Transaction Categorization Rules (auto-tag transactions during CSV import)
model TransactionCategorizationRule {
  id                String   @id @default(cuid())
  descriptionString String // The pattern to match against transaction descriptions
  exactMatch        Boolean  @default(false) // true = exact match, false = partial/contains match
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  spendingTypes              CategorizationRuleSpendingType[]
  appliedTransactionTypes    TransactionSpendingType[] // Track which transaction spending types were applied by this rule

  @@index([descriptionString])
}

// Junction table: many-to-many between TransactionCategorizationRule and SpendingType
model CategorizationRuleSpendingType {
  id                     String @id @default(cuid())
  categorizationRuleId   String
  spendingTypeId         String

  categorizationRule TransactionCategorizationRule @relation(fields: [categorizationRuleId], references: [id], onDelete: Cascade)
  spendingType       SpendingType                  @relation(fields: [spendingTypeId], references: [id], onDelete: Cascade)

  @@unique([categorizationRuleId, spendingTypeId])
  @@index([categorizationRuleId])
  @@index([spendingTypeId])
}

// Data Format (defines CSV format types)
model DataFormat {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "HalifaxAccountExportCSV"
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  uploadOperations UploadOperation[]
}

// Upload Operation (tracks CSV uploads)
model UploadOperation {
  id                String                @id @default(cuid())
  filename          String
  uploadDateTime    DateTime              @default(now())
  fileType          String                @default(".csv") // e.g., ".csv"
  operationStatus   UploadOperationStatus @default(PENDING)
  fileSize          Int? // File size in bytes
  numberOfRecords   Int? // Number of records processed
  fileS3Location    String? // Future: AWS S3 location
  localFileLocation String? // Local file path for uploaded CSV
  errorMessage      String? // Store error details if FAILED

  // Preflight check data
  earliestDate          DateTime? @db.Date // Earliest transaction date in CSV
  latestDate            DateTime? @db.Date // Latest transaction date in CSV
  detectedAccountNumber String? // Account number detected from CSV
  detectedSortCode      String? // Sort code detected from CSV

  // Relations
  dataFormatId String
  dataFormat   DataFormat @relation(fields: [dataFormatId], references: [id], onDelete: Restrict)

  bankAccountId String? // Now optional until preflight completes
  bankAccount   BankAccount? @relation(fields: [bankAccountId], references: [id], onDelete: Restrict)

  // Link to transaction records via junction table
  transactionSources TransactionUploadSource[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bankAccountId])
  @@index([dataFormatId])
  @@index([operationStatus])
  @@index([uploadDateTime])
  @@index([earliestDate])
  @@index([latestDate])
}

// Junction table: links TransactionRecords to their source UploadOperations
// Captures the row number from the CSV to maintain transaction order
model TransactionUploadSource {
  id                  String @id @default(cuid())
  transactionRecordId String
  uploadOperationId   String
  csvRowNumber        Int // The row number in the original CSV file (0-indexed or 1-indexed)

  transactionRecord TransactionRecord @relation(fields: [transactionRecordId], references: [id], onDelete: Cascade)
  uploadOperation   UploadOperation   @relation(fields: [uploadOperationId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([transactionRecordId, uploadOperationId])
  @@index([transactionRecordId])
  @@index([uploadOperationId])
  @@index([csvRowNumber])
}

// Activity Log (tracks user actions and system operations)
model ActivityLog {
  id String @id @default(cuid())

  // User context (for future multi-user support)
  userId String @default("HumanUser") // Hardcoded for now, future: actual user ID

  // Activity identification
  activityName        String       // kebab-case from ActivityType enum
  activityDisplayName String       // Human-friendly display name
  activityType        ActivityType // Enum value for type safety
  status              ActivityStatus @default(ONGOING)

  // Timing
  startTime DateTime @default(now())
  endTime   DateTime?

  // Result details
  message      String? // Summary of what was done or error message
  metadata     Json? // Flexible storage for operation-specific data (counts, IDs, etc.)
  errorDetails String? // Stack trace or detailed error info

  // Progress tracking (for long-running operations)
  progress       Int? // 0-100 percentage
  totalItems     Int? // Total items to process
  processedItems Int? // Items processed so far

  // Entity context (what was affected)
  entityType String? // e.g., "TransactionRecord", "CategorizationRule"
  entityId   String? // ID of the primary affected entity

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([activityType])
  @@index([status])
  @@index([startTime])
  @@index([createdAt])
}
